# План реализации фич GROSS:форум

Ниже — как реализовать каждую из заявленных возможностей: идея, БД, API, UI и порядок внедрения.

---

## 1. Редактирование поста автором в UI

**Идея:** Автор поста видит кнопку «Изменить пост» (не только админ). По клику — форма или prompt с заголовком и телом, сохранение через API.

**БД:** Уже есть: RLS `posts_update` с `auth.uid() = author_id`. Дополнительно не нужно.

**API (data-supabase.js):**
- Добавить `updatePost(postId, { title, body })`: `sb.from('posts').update({ title, body, updated_at: new Date().toISOString() }).eq('id', postId).select().single()` — RLS сам проверит автора.
- Экспортировать в `window.BizForum.data.updatePost` (или оставить только админский `adminUpdatePost` и вызывать его только для админа; для автора — отдельный метод без RPC).

**UI (app.js):**
- В `loadPost` при `currentUserIsPostAuthor && !adminModeOn` показывать кнопку «Изменить пост» (уже показывается панель автора с «Удалить»; добавить рядом «Изменить»).
- По клику: `prompt` для заголовка и тела (или модалка с полями), вызов `BizForum.data.updatePost(postId, { title, body })`, затем `loadPost(postId)`.

**Порядок:** Сделать первым (мало кода, сразу полезно).

---

## 2. Черновики постов

**Идея:** При создании поста можно сохранить в черновик (статус `draft`). В ленте черновики не показываются; в профиле или отдельном разделе «Мои черновики» — список, можно дописать и опубликовать.

**БД:**
- В таблицу `posts` добавить колонку `status TEXT NOT NULL DEFAULT 'published' CHECK (status IN ('draft', 'published'))`.
- Или отдельная таблица `post_drafts (user_id, post_id, title, body, category_id, updated_at)` — тогда посты без черновика не трогаем. Проще вариант с колонкой `status`.

**API:**
- `createPost`: при черновике вставлять `status: 'draft'`.
- `getPosts` / лента: фильтр `status = 'published'` (и по категориям).
- `getMyDrafts()`: посты текущего пользователя с `status = 'draft'`.
- `publishPost(postId)`: `update posts set status = 'published' where id = postId and author_id = auth.uid()`.
- RLS: SELECT для постов — только `status = 'published'` для всех; для автора — и свои черновики (OR author_id = auth.uid()).

**UI:**
- В форме «Новый пост» кнопка «Сохранить черновик» рядом с «Опубликовать». По «Черновик» — вызов `createPost(..., { draft: true })` или отдельный метод.
- Раздел «Мои черновики» (ссылка в профиле или сайдбаре): список черновиков, клик — открыть форму редактирования и кнопка «Опубликовать».

**Порядок:** После редактирования поста автором.

---

## 3. Вложения (картинки, файлы)

**Идея:** В посте и/или в комментарии можно прикрепить файл (сначала картинки, опционально PDF). Хранить в Supabase Storage, в БД — URL или путь.

**БД:**
- Вариант А: в `posts` колонка `attachments JSONB` (массив `[{ url, name, type }]`).
- Вариант Б: таблица `post_attachments (id, post_id, file_url, file_name, mime_type, created_at)`.
- Для комментариев: `comment_attachments` или поле `attachments` в `comments` (JSONB).

**Storage (Supabase):**
- Bucket `attachments` (или `public-files`), политика: загрузка для авторизованных (или всех для постов), чтение публичное. Путь например `posts/{postId}/{filename}` или `{userId}/{uuid}_{filename}`.

**API:**
- `uploadFile(file, opts)`: загрузка в Storage, возврат публичного URL.
- `createPost` / `updatePost`: принимать массив файлов или URL после загрузки, сохранять в БД.
- `addComment`: опционально те же вложения (URL в теле или отдельное поле).

**UI:**
- В форме поста и в форме комментария: кнопка «Прикрепить», input type=file (accept="image/*,.pdf"), превью картинок, список имён файлов. Перед отправкой поста/коммента — загрузить файлы, подставить URL в данные.

**Порядок:** После черновиков (можно делать поэтапно: сначала только картинки в постах).

---

## 4. Упоминания @

**Идея:** В тексте комментария (или поста) писать @Имя Фамилия или @email; при сохранении парсить упоминания, создавать уведомления указанным пользователям.

**БД:** Не обязательно новая таблица. Достаточно таблицы `notifications`: при вставке комментария бэкенд или клиент определяет, кого упомянули, и создаёт записи с типом `mention`.

**API:**
- Поиск пользователей по подстроке для автодополнения: RPC `search_profiles_for_mention(p_query)` — по имени/фамилии/email, возвращать id, display_name.
- При отправке комментария: парсить body на паттерн `@...` (или маркдаун-синтаксис). Для каждого упомянутого: `createNotification(userId, 'mention', { post_id, comment_id, from_user_id })`.
- Вариант с сервером: триггер на INSERT в `comments` — парсинг body и вставка в `notifications` (нужна функция на pl/pgsql).

**UI:**
- В textarea комментария (и поста): при вводе `@` показывать выпадающий список найденных пользователей (вызов search по введённой подстроке). Выбор вставляет id или slug в текст (например `@[Иван Петров](user:uuid)`), при отображении — ссылка на профиль или просто имя.
- Либо простой вариант без автодополнения: просто парсить готовый текст на `@имя` и искать пользователя по имени при сохранении.

**Порядок:** После уведомлений (уже есть createNotification), можно делать параллельно с пуш/email.

---

## 5. Теги

**Идея:** К посту можно привязать теги (например #налоги #удалёнка). Поиск и фильтр ленты по тегу.

**БД:**
- Таблица `tags (id, name UNIQUE, slug UNIQUE)`.
- Таблица `post_tags (post_id, tag_id)`, PRIMARY KEY (post_id, tag_id). Или теги в постах как JSONB `post_tags TEXT[]` / `tags JSONB`.
- Простой вариант: в `posts` колонка `tags TEXT[]` — массив строк (имена тегов). Поиск: `WHERE 'налоги' = ANY(tags)`.

**API:**
- `getTags()` или автосоздание: при публикации поста извлекать из текста/поля теги, создавать записи в `tags` и связи в `post_tags` (или писать в `posts.tags`).
- `getPosts({ tag: 'налоги' })`: фильтр по тегу.
- Поиск по тегам в расширенном поиске.

**UI:**
- В форме поста: поле «Теги» (input с подсказкой «через запятую» или чипы). При сохранении — передавать массив тегов.
- В карточке поста и на странице поста — отображать теги ссылками на «ленту по тегу» (#/tag/налоги).
- В расширенном поиске — фильтр по тегу (select или мультиселект).

**Порядок:** После расширенного поиска (фильтр по тегу логично в одном месте).

---

## 6. Подписка на авторов / обсуждения

**Идея:** «Подписаться на автора» — в ленте или в уведомлениях видеть новые посты этого автора. «Подписаться на обсуждение» — получать уведомления о новых комментариях в посте.

**БД:**
- Таблица `subscriptions` или две: `user_subscriptions (user_id, target_type, target_id)`. `target_type` = 'author' | 'post', `target_id` = user_id поста или post_id.
- Уникальность: (user_id, target_type, target_id).

**API:**
- `subscribeToAuthor(authorUserId)`, `unsubscribeFromAuthor(authorUserId)`.
- `subscribeToPost(postId)`, `unsubscribeFromPost(postId)`.
- При создании поста: выбрать подписчиков автора из `user_subscriptions` где target_type='author', target_id=author_id, вставить уведомления.
- При добавлении комментария: выбрать подписчиков поста (target_type='post', target_id=post_id), вставить уведомления (кроме автора комментария).

**UI:**
- На странице поста: кнопка «Следить за обсуждением» (подписка на пост). В карточке автора или в профиле: «Подписаться на автора».
- В настройках профиля или отдельная страница «Подписки» — список, отписка.

**Порядок:** После доработки уведомлений (пуш/email), чтобы подписки сразу давали доставку.

---

## 7. Репутация / бейджи

**Идея:** Очки репутации за полезные действия (лучшие ответы, реакции на комментарии, активность). Бейджи: «Эксперт по категории», «Верифицирован», «Активный участник».

**БД:**
- В `profiles` колонки `reputation INT DEFAULT 0`, `badges JSONB` (массив строк или объектов { type, granted_at }).
- Или таблица `user_badges (user_id, badge_type, granted_at)`. Начисление репутации: триггер при отметке «лучший ответ», при получении реакций и т.д.

**API:**
- `getProfile()` возвращает reputation и badges.
- Функция начисления: при setBestAnswer — +N автору комментария; при новой реакции на комментарий — +1 автору комментария (опционально). Бейджи выдавать по правилам (например reputation > 100 → «Активный»).

**UI:**
- В профиле и рядом с именем в постах/комментариях: число репутации и иконки бейджей (подсказка по наведению).
- Опционально: страница «Лидеры» или «Топ по категории».

**Порядок:** После подписок и стабилизации контента (чтобы правила начисления были понятны).

---

## 8. Расширенный поиск (категория, даты)

**Идея:** В поиске добавить фильтры: категория (select), дата «с» / «по». Результаты можно сортировать (по дате, по релевантности).

**БД:** Не меняется. Уже есть поиск по title/body; добавляем только условия в запросе.

**API (data-supabase.js):**
- Расширить `searchPosts(query, opts)`: `opts.categoryId` → `.eq('category_id', opts.categoryId)`; `opts.dateFrom` / `opts.dateTo` (ISO) → `.gte('created_at', ...)` и `.lte('created_at', ...)`. Сортировка: `opts.sortBy` = 'relevance' | 'date' | 'comments'.

**UI:**
- На экране поиска (или в шапке рядом с полем): выпадающий «Категория» (все + список), два input type=date «С» / «По», кнопка «Найти». При отправке формировать opts и вызывать searchPosts(q, opts). Результаты отображать как сейчас, опционально — переключатель сортировки.

**Порядок:** Ранний (мало кода, сразу польза при росте контента).

---

## 9. Пуш / email-уведомления

**Идея:** При новых ответах в посте, упоминаниях, заявках в друзья и т.д. — отправлять пуш в браузере и/или письмо на email.

**Пуш (браузер):**
- Service Worker + Push API. Подписка на пуш: VAPID ключи в Supabase или отдельном сервисе; при событии (новый комментарий и т.д.) вызывать внешний сервис отправки пуша (или Supabase Edge Function), который шлёт пуш подписчику.
- Альтернатива: периодический опрос `getNotifications()` и показ браузерного Notification API при новых непрочитанных (без серверного пуша).

**Email:**
- Вариант 1: Supabase Auth — встроенные письма (подтверждение email и т.д.); кастомные письма — через Edge Function + внешний SMTP/сервис (Resend, SendGrid).
- Вариант 2: Edge Function по триггеру (INSERT в notifications): для типа comment_on_post, reply_to_comment, mention и т.д. — запрос к почтовому API, отправка «Вам ответили в посте …» с ссылкой.

**БД:** В `notifications` уже есть тип и payload. Опционально: в `profiles` флаги `notify_email`, `notify_push` и настройки «что уведомлять».

**UI:**
- В настройках профиля: «Уведомления по email» (вкл/выкл), «Уведомления в браузере» (вкл/выкл + запрос разрешения на пуш). При первом включении пуша — запрос Notification.requestPermission и сохранение подписки (токен) в БД (таблица `push_subscriptions`).

**Порядок:** После подписки на обсуждения; сначала email (проще), потом пуш.

---

## 10. Жалобы и модерация

**Идея:** Кнопка «Пожаловаться» у поста и комментария. Выбор причины (спам, оскорбление, другое). Очередь жалоб для админов; решение: отклонить или принять (удалить контент, предупреждение пользователю).

**БД:**
- Таблица `reports (id, reporter_id, target_type, target_id, reason, status, created_at, resolved_at, resolved_by)`. `target_type` = 'post' | 'comment', `target_id` = id поста/комментария. `reason` = текст или enum. `status` = 'pending' | 'rejected' | 'accepted'.
- RLS: вставка — любой авторизованный; чтение — только админы (через RPC или политика по роли).

**API:**
- `createReport({ targetType, targetId, reason })`.
- Админ: `getReports(status)`, `resolveReport(reportId, action)` (accept/reject), при accept — вызов удаления поста/комментария и при необходимости создание уведомления автору.

**UI:**
- Под постом и под комментарием: «Пожаловаться». По клику — модалка с выбором причины и полем «Комментарий», отправка.
- В админке раздел «Жалобы»: список, фильтр по статусу, кнопки «Отклонить» / «Удалить контент».

**Порядок:** После стабилизации контента и админки; можно делать параллельно с репутацией.

---

## 11. Доработка ЛС (личные сообщения)

**Идея:** Полноценные личные сообщения: список диалогов, выбор собеседника (из друзей или по поиску), история сообщений, отправка, уведомления о новых сообщениях.

**БД:** Уже есть заготовка: `conversations`, `conversation_participants`, `messages`. Нужно проверить RLS и индексы.

**API:**
- `getConversations()` — список диалогов с последним сообщением и счётчиком непрочитанных (уже есть частично).
- `getMessages(conversationId)` — история (уже есть).
- `sendMessage(conversationId, body)` — отправка (есть).
- При отправке сообщения — создание уведомления получателю (уже есть createNotification для message_reply).
- Отметка сообщений как прочитанных: в `messages` колонка `read_by` (массив user_id) или отдельная таблица `message_read (message_id, user_id)`.

**UI:**
- Раздел «Чаты» / «Сообщения»: слева список диалогов (аватар, имя, превью последнего сообщения, время, бейдж непрочитанных). Справа — выбранный диалог: история сообщений, поле ввода, кнопка «Отправить».
- Создание нового диалога: «Написать» → выбор пользователя (из друзей или поиск) → создание/открытие conversation, фокус на поле ввода.
- В шапке иконка «Чаты» с бейджем непрочитанных (сумма по всем диалогам).

**Порядок:** После уведомлений и подписок; можно поэтапно (сначала только список и отправка, потом прочитанность и пуш).

---

## Рекомендуемый порядок внедрения

| Этап | Фича | Зачем |
|------|------|--------|
| 1 | Редактирование поста автором | Быстро, ожидаемое поведение |
| 2 | Расширенный поиск (категория, даты) | Мало кода, большая польза |
| 3 | Черновики | Удобство создания постов |
| 4 | Вложения (картинки в постах) | Ценность контента |
| 5 | Упоминания @ | Диалог и уведомления |
| 6 | Подписка на обсуждения | Удержание |
| 7 | Email-уведомления | Возвраты |
| 8 | Пуш-уведомления | Мгновенная доставка |
| 9 | Теги | Поиск и фильтры |
| 10 | Репутация / бейджи | Мотивация и доверие |
| 11 | Жалобы и модерация | Безопасность |
| 12 | Доработка ЛС (прочитанность, список) | Полноценные личные диалоги |

После каждого этапа можно выпускать версию и собирать обратную связь.
